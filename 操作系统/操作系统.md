# [[操作系统]]

## 程序的运行过程：代码到机器运行

### 程序编译过程

```c

#include "stdio.h"
int main(int argc, char const *argv[])
{
  printf("Hello World!\n");
  return 0;
}
```

计算机硬件是无法直接运行这个 C 语言文本程序代码的，需要 C 语言编译器，把这个代码编译成具体硬件平台的二进制代码。再由具体操作系统建立进程，把这个二进制文件装进其进程的内存空间中，才能运行

gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld ，就可以编译这段代码
![](图片/Pasted%20image%2020231010094858.png)
* gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入头文件，替换宏。
* gcc HelloWorld.c -S -c -o HelloWorld.s 编译：包含预处理，将 C 程序转换成汇编程序。
* gcc HelloWorld.c -c -o HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。
* gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。

### 程序装载执行

* 图灵机

![image-20221125141934629](../assets/image-20221125141934629.png)

* 冯诺依曼体系结构
  * 必须具有如下功能
    * 把程序和数据装入计算机；
    * 必须具有长期记住程序，数据的中间结果及最终运算结果；
    * 完成各种算术，逻辑运算和数据传送等数据加工处理；
    * 根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；
    * 能够按照要求将处理的数据结果显示给用户。

* 必须具备的五大基本组成部件：
  * 装载数据和程序的输入设备
  * 记住程序和数据的存储器
  * 完成数据加工处理的运算器
  * 控制程序执行的控制器
  * 显示处理结果的输出设备

### 思考题

为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？

在执行完call指令的同时，需要将call指令下面一条指令的地址保存到栈内存中，同时更新%rsp寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，由ret指令从rsp中获取栈顶的returnadress地址

## 几行汇编几行C：实现一个最简单的内核（hello os）

Hello OS的引导流程

![image-20221125151529553](../assets/image-20221125151529553.png)

PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的，掉电也能保存，PC 机上电后的第一条指令就是 BIOS 固件中的，它负责**检测和初始化 CPU、内存及主板平台**，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。
[[UEFI BIOS]]
### Hello OS 引导汇编代码
**C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要用栈。******
```c
MBT_HDR_FLAGS EQU 0x00010003
MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数
MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数
global _start ;导出_start符号
extern main ;导入外部的main函数符号
[section .start.text] ;定义.start.text代码节
[bits 32] ;汇编成32位代码
_start:
jmp _entry
ALIGN 8
mbt_hdr:
dd MBT_HDR_MAGIC
dd MBT_HDR_FLAGS
dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)
dd mbt_hdr
dd _start
dd 0
dd 0
dd _entry
;以上是GRUB所需要的头
ALIGN 8
mbt2_hdr:
DD MBT_HDR2_MAGIC
DD 0
DD mbt2_hdr_end - mbt2_hdr
DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))
DW 2, 0
DD 24
DD mbt2_hdr
DD _start
DD 0
DD 0
DW 3, 0
DD 12
DD _entry
DD 0
DW 0, 0
DD 8
mbt2_hdr_end:
;以上是GRUB2所需要的头
;包含两个头是为了同时兼容GRUB、GRUB2
ALIGN 8
_entry:
;关中断
cli
;关不可屏蔽中断
in al, 0x70
or al, 0x80
out 0x70,al
;重新加载GDT
lgdt [GDT_PTR]
jmp dword 0x8 :_32bits_mode
_32bits_mode:
;下面初始化C语言可能会用到的寄存器
mov ax, 0x10
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
xor eax,eax
xor ebx,ebx
xor ecx,ecx
xor edx,edx
xor edi,edi
xor esi,esi
xor ebp,ebp
xor esp,esp
;初始化栈，C语言需要栈才能工作
mov esp,0x9000
;调用C语言函数main
call main
;让CPU停止执行指令
halt_step:
halt
jmp halt_step
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
k16cd_dsc: dq 0x00009e000000ffff
k16da_dsc: dq 0x000092000000ffff
GDT_END:
GDT_PTR:
GDTLEN dw GDT_END-GDT_START-1
GDTBASE dd GDT_START
```

1. 代码 1~40 行，用汇编定义的 GRUB 的多引导协议头，其实就是一定格式的数据，我们的 Hello OS 是用 GRUB 引导的，当然要遵循 GRUB 的多引导协议标准，让 GRUB 能识别我们的 Hello OS。之所以有两个引导头，是为了兼容 GRUB1 和 GRUB2。
2. 代码 44~52 行，关掉中断，设定 CPU 的工作模式。
3. 代码 54~73 行，初始化 CPU 的寄存器和 C 语言的运行环境。
4. . 代码 78~87 行，GDT_START 开始的，是 CPU 工作模式所需要的数据
### Hello OS主函数
```c
#include "vgastr.h"
void main()
{
  printf("Hello OS!");
  return;
} 
```
vgastr.h头文件 包含自己实现的printf函数 而非 应用程序库中的printf
### 控制计算机屏幕
无论pc上是什么显卡，都支持一种VESA的标准，具有两种工作模式：字符模式与图像模式
并提供一种VGABIOS固件程序
![image-20221127131922300](../assets/image-20221127131922300.png)
**提示**：C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的
```c
void _strwrite(char* string)
{
  char* p_strdst = (char*)(0xb8000);//指向显存的开始地址
  while (*string)
  {
    *p_strdst = *string++;
    p_strdst += 2;
  }
  return;
}

void printf(char* fmt, ...)
{
  _strwrite(fmt);
  return;
}
```
### 编译和安装Hello OS
#### make 工具
* 在软件开发中，make 是一个工具程序，它读取一个叫“makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件。
* makefile 文件中规则是这样的：首先有一个或者多个构建目标称为“target”；目标后面紧跟着用于构建该目标所需要的文件，目标下面是构建该目标所需要的命令及参数。
* 与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。
* 第一次构建目标后，下一次执行 make 时，它会根据该目标所依赖的文件是否更新决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。
```c
CC = gcc #定义一个宏CC 等于gcc
CFLAGS = -c #定义一个宏 CFLAGS 等于-c
OBJS_FILE = file.o file1.o file2.o file3.o file4.o #定义一个宏
.PHONY : all everything #定义两个伪目标all、everything
all:everything #伪目标all依赖于伪目标everything
everything :$(OBJS_FILE) #伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被
#替换成file.o file1.o file2.o file3.o file4.o
%.o : %.c #所有以".o"结尾的文件依赖于所有以".c"结尾的文件
   $(CC) $(CFLAGS) -o $@ $<
```
* makefile 中可以定义宏，方法是在一个字符串后跟一个“=”或者“:=”符号，引用宏时要用“$(宏名)”，宏最终会在宏出现的地方替换成相应的字符串，例如：$(CC) 会被替换成 gcc，$( OBJS_FILE) 会被替换成 file.o file1.o file2.o file3.o file4.o。
* .PHONY 在 makefile 中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令。但是**伪目标可以依赖于另一个伪目标或者文件**
* everything 下面并没有相关的执行命令，但是下面有个通用规则：“%.o : %.c”。其中的“%”表示通配符，**表示所有以“.o”结尾的文件依赖于所有以“.c”结尾的文件。**
	* 例如：file.c、file1.c、file2.c、file3.c、file4.c，通过这个通用规则会自动转换为依赖关系：file.o: file.c、file1.o: file1.c、file2.o: file2.c、file3.o: file3.c、file4.o: file4.c。
* **$(CC) $(CFLAGS) -o $@ $<** 命令，当然最终会转换为：gcc –c –o xxxx.o xxxx.c，这里的“xxxx”表示一个具体的文件名。
### 编译
![image-20221127131900105](../assets/image-20221127131900105.png)
### 安装Hello OS
* Hello OS的启动项
```c
menuentry 'HelloOS' {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root='hd0,msdos4' #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
```
[[linux]]系统的终端下输入命令：df /boot/
```
文件系统          1K-块    已用     可用      已用% 挂载点
/dev/sda4      48752308 8087584 38158536   18%    /
```
* **注意：*** 其中的“sda4”就是硬盘的第四个分区（硬件分区选择 MBR），但是 GRUB 的 menuentry 中不能写 sda4，而是要写“hd0,msdos4”，这是 GRUB 的命名方式，hd0 表示第一块硬盘，结合起来就是第一块硬盘的第四个分区。
* 把上面启动项的代码插入到你的 Linux 机器上的 /boot/grub/grub.cfg 文件末尾，然后把 Hello OS.bin 文件复制到 /boot/ 目录下，一定注意这里是追加不是覆盖。最后重启计算机，你就可以看到 Hello OS 的启动选项了。

## 内核结构与设计

### 黑盒之中有什么

* 抽象的角度看，内核就是计算机资源的管理者

* 大致可以分为硬件资源与软件资源

  * **硬件资源**

    * **总线**：负责连接各种其他设备，是其他设备工作的基础

    * **CPU**：即中央处理器，负责执行程序和处理数据运算

    * **内存**：负责存储运行时的代码和数据

    * **硬盘**：负责长久存储用户文件数据

    * **网卡**：负责计算机与计算机之间的通信

    * **显卡**：负责显示工作

    * **各种I/O设备**：如显示器，打印机，键盘，鼠标等

      ![image-20221127184317620](../assets/image-20221127184317620.png)

  * 软件资源

    * 可以表示为计算机中的各式各样的数据，如各种文件，软件程序等

* 内核其内部组成的逻辑

1. **管理CPU**：由于CPU时执行程序的，而内核把运作时的程序抽象成进程，所以又称为进程管理
2. **管理内存**：由于程序和数据都要占用内存，内存是非常宝贵的资源，所以内核要非常小心地分配，释放内存
3. **管理硬盘**：主要存放用户数据，而内核把用户数据抽象成文件，即管理文件，文件需要合理地组织，方便用户查找和读写，所以形成了文件系统
4. **管理显卡**：负责显示信息，而现在操作系统都是支持GUI（图形用户接口）的，管理显卡自然而然地就成了内核中的图形系统
5. **管理网卡**：网卡主要完成网络通信，网络通信需要各种通信协议，最后在内核中就形成了网络协议栈，又称啊网络组件
6. **管理各种I/O设备**：（输入输出）设备，在内核中抽象成I/O管理器

各种计算机硬件的性能不同，硬件型号不同，硬件种类不同，硬件厂商不同，内核要想管理和控制这些硬件就要编写对应的代码，通常这样的代码我们称之为驱动程序。

### 宏内核结构

* 宏内核就是把以上诸如管理进程的代码，管理内存的代码，管理各种I/O设备的代码，文件系统的代码，图形系统代码以及其他功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序
* 这个程序内有实现这些功能的所有代码，向用户应用软件提供一些接口，这些接口就是常说的系统API函数。而这个大程序会在处理器的特权模式下运行，这个模式通常被称为宏内核模式

![image-20221127194151147](../assets/image-20221127194151147.png)

* **宏内核提供内存分配功能的服务过程**
  * 应用程序调用内存分配的API（应用程序接口）函数
  * 处理器切换到特权模式，开始运行内核代码
  * 内核里的内存管理代码按照特定的算法，分配一块内存
  * 把分配的内存块的首地址，返回给内存分配的API函数
  * 内存分配的API函数返回，处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存

* 缺点：
  * 没有模块化，没有扩展性，没有移植性
  * 高度耦合，一个组件有漏洞，内核中所有组件可能都会出问题
  *  开发一个新功能需要重新编译，链接，安装内核

* 优点
  * 性能好

### 微内核结构

* 与宏内核架构刚好相反，提倡内核功能尽可能少
* 只有进程调度，处理中断，内存空间映射，进程通信等功能

**微内核定义了一种良好的进程间通信的机制——消息**

* 应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。
* 服务进程的编程模型就是循环处理来自其他进程的消息，完成相关的服务功能

![image-20221127224533613](../assets/image-20221127224533613-1669560341699-1.png)

* **微内核提供内存分配功能的服务过程**
  * 应用程序发送内存分配的消息，这个发送消息的函数是微内核提供的，相当于系统API，微内核的API（应用程序接口）相当少，极端情况下仅需要两个，一个接收消息的API和一个发送消息的API
  * 处理器切换到特权模式，开始运行内核代码
  * 微内核代码让当前进程停止运行，并根据消息包中的数据，确定消息发送给谁，分配内存的消息发送给内存管理服务进程
  * 内存管理服务进程收到消息，分配一块内存
  * 内存管理服务进程，也会通过消息的形式返回分配内存块的地址给内核，然后继续等待下一条消息
  * 微内核把包含内存块地址的消息返回给发送内存分配消息的应用程序
  * 处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存

* **优点**
  * 系统结构清晰，利于协作开发
  * 具有良好的移植性，微内核代码量非常少
  * 具有相当好的伸缩性，扩展性

### 分离硬件的相关性

* **操作系统内核分层**
  * 目的与好处：屏蔽底层细节，使上层开发更加简单

* **分离硬件的相关性就是要把操作硬件和处理硬件功能差异的代码抽离出来，形成一个独立的软件抽象层**

#### 例子

* 进程调度模块

* 进程是操作系统开发者为了实现多任务而提出的，并让每个进程在 CPU 上运行一小段时间，这样就能实现多任务同时运行的假象。

  * **进程调度**
    * 它的目的是要从众多进程中选择一个将要运行的进程，当然有各种选择的算法，例如，轮转算法、优先级算法等

  * **进程切换**
    * 它的目的是停止当前进程，运行新的进程，主要动作是保存当前进程的机器上下文，装载新进程的机器上下文。

不管是在 ARM 硬件平台上还是在 x86 硬件平台上，选择一个进程的算法和代码是不容易发生改变的，需要改变的代码是进程切换的相关代码，因为不同的硬件平台的机器上下文是不同的。

这就可以将进程切换的代码放在一个独立的层中实现（硬件平台相关层），当操作系统要运行在不同的硬件平台时，只需要修改硬件平台层中的相关代码

### 我们的选择

* 将内核分为三层
  * 内核接口层
    * 定义了一套 UNIX 接口的子集，我们出于学习和研究的目的，使用 UNIX 接口的子集，优点之一是接口少，只有几个，并且这几个接口又能大致定义出操作系统的功能
    * 这套接口的代码，就是检查其参数是否合法，如果参数有问题就返回相关的错误，接着调用下层完成功能的核心代码。
  * 内核功能层
    * **进程管理**，主要是实现进程的创建、销毁、调度进程，当然这要设计几套数据结构用于表示进程和组织进程，还要实现一个简单的进程调度算法。
    * **内存管理**，在内核功能层中只有内存池管理，分两种内存池：页面内存池和任意大小的内存池，你现在可能不明白什么是内存池，这里先有个印象就行，后面课程研究它的时候再详细介绍
    * **中断管理**，这个在内核功能层中非常简单：就是把一个中断回调函数安插到相关的数据结构中，一旦发生相关的中断就会调用这个函数。
    * **设备管理，**这个是最难的，需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备，最后把它们组织在一起，还要实现创建设备、销毁设备、访问设备的代码，这些代码最终会调用设备驱动程序，达到操作设备的目的。
  * 内核硬件层
    * **初始化**，初始化代码是内核被加载到内存中最先需要运行的代码，例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构等
    * **CPU 控制**，提供 CPU 模式设定、开、关中断、读写 CPU 特定寄存器等功能的代码
    * **中断处理**，保存中断时机器的上下文，调用中断回调函数，操作中断控制器等
    * **物理内存管理**，提供分配、释放大块内存，内存空间映射，操作 MMU、Cache 等
    * 平台其它相关的功能，有些硬件平台上有些特殊的功能，需要额外处理一下

![image-20221127231856672](../assets/image-20221127231856672.png)